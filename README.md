# August ü™ì

**August** is an assembler written from scratch in [Ink](https://dotink.co/) for me to learn about assemblers, linkers, and compiler backends. It currently aims to support assembling and statically linking [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) executables for ARM, RISC-V, and x86_64 architectures, though Mach-O support for ARM and x86_64 are under consideration. In the long term, August might also become a code generation backend for a compiler for some small subset of C written in Ink.

_August is ‚ö†Ô∏è under development ‚ö†Ô∏è. Many parts of the system do not work at all yet._

## Design

August provides a CLI, `./src/cli.ink`, that currently takes a single assembly program and emits a single statically-linked x86_64 ELF executable. Under the hood, August reads the assembly program, parses it into a simple representation of symbols and sections in the source, assembles it into machine code, and links it all together with a minimal ELF linker.

At the moment, the assembler and linker are pretty tightly integrated. The ELF linker assumes that only two sections are used, `.text` and `.rodata`, and the assembler generates code with that assumption. The virtual address table for the generated executable is also currently hard-coded into the linker and relied on by the assembler when resolving symbols.

Here's a transcript of a shell session that demonstrates what August can do today. We take a bare-bones Hello World program for Linux on x86_64, assemble it with August, run it, and dump the generated assembly with `objdump`.

```asm
$ cat test/asm/004.asm
; Hello World

section .text

mov eax 0x1     ; write syscall
mov edi 0x1     ; stdout
mov esi msg     ; string to print
mov edx len     ; length
syscall

mov eax 60      ; exit syscall
mov edi 0       ; exit code
syscall

section .rodata

msg:
    db "Hello, World!" 0xa
len:
    eq 14
```

Run the emitted program, which prints, "Hello, World!" and exits cleanly.

```bash
$ august test/asm/004.asm ./hello-world
executable written.

$ ./hello-world
Hello, World!

$ echo $?
0
```

If we disassemble the generated executable, we find the assembly we began with.

```asm
$ objdump -d ./hello-world

./hello-world:     file format elf64-x86-64

Disassembly of section .text:

0000000000401000 <.text>:
  401000:    b8 01 00 00 00           mov    $0x1,%eax
  401005:    bf 01 00 00 00           mov    $0x1,%edi
  40100a:    be 00 50 6b 00           mov    $0x6b5000,%esi
  40100f:    ba 0e 00 00 00           mov    $0xe,%edx
  401014:    0f 05                    syscall
  401016:    b8 3c 00 00 00           mov    $0x3c,%eax
  40101b:    bf 00 00 00 00           mov    $0x0,%edi
  401020:    0f 05                    syscall
    ...
```

### Assembler

The instruction encoding is handled by the [`./src/asm.ink`](src/asm.ink) library within the project. Currently, August can assemble simple programs that work with 32-bit registers and the ALU, make system calls and function calls per the x86 calling convention, and read or write to memory. Even with these basic building blocks, we can write programs that do interesting things like loop, branch, manipulate memory, and make recursive calls. You can check out some examples in [`test/asm/`](test/asm/).

_more to come._

### ELF Linker

August uses a library for constructing ELF executable files located at [`./src/elf.ink`](src/elf.ink). The ELF generated by the ELF library in August currently makes use of three sections:

- `.text` containing the program text, i.e. translated x64 assembly.
- `.rodata` containing read-only data loaded into process memory as read-only
- `.shstrtab` containing section headers

The content of `.text` and `.rodata` sections can be provided to the ELF library, which will return a fully linked ELF binary as the result.

_more to come._

## References and further reading

The ELF file format is quite well documented, especially in source bases of various linkers, assemblers, and kernels, but the available reference material for _implementing_ an ELF linker is not...what you would call super accessible. In the process of building August, I've found the following references particularly helpful.

- [`man elf` on Linux](https://man7.org/linux/man-pages/man5/elf.5.html) and the `elf` header file in the kernel sources, which provide the canonical reference for implementations of ELF files
- [A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux](http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html), which breaks down the ELF format for executable files at a high level
- [LWN's write-up of the Linux kernel's view of ELF executables](https://lwn.net/Articles/631631/), with another breakdown of ELF executables
- [Solaris's documentation on ELF object files](https://docs.oracle.com/cd/E53394_01/html/E54813/chapter6-93046.html#scrolltoc), a good in-depth reference
- [Notes on the ELF specification](http://www.muppetlabs.com/~breadbox/software/ELF.txt), which is long but very, very comprehensive, occasionally useful for studying edge cases

In writing an x86/x64 assembler, the following were especially helpful to get me up to speed.

- [The x86asm.net ISA reference](http://ref.x86asm.net/coder64.html), which is comprehensive enough for a toy assembler and easy to navigate once you get used to the compact notation
- [Encoding x86 Instructions](http://www.cs.loyola.edu/~binkley/371/Encoding_Real_x86_Instructions.html), which was a helpful guide to understanding how x86 and x64 instructions are encoded
- The [x64 cheat sheet](http://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf) for a handy list of the core x86/x64 instruction set
- The [Calling Conventions](https://wiki.osdev.org/Calling_Conventions) article on OSDev Wiki

## Development

To work on August, you obviously need [Ink](https://dotink.co/) installed. [Inkfmt](https://github.com/thesephist/inkfmt) is also useful for auto-formatting code, which you can run with `make format` or `make f`.

When I work on August (especially the assembler), I usually have two other panes open, running:

- `ls test/asm/*.asm lib/*.ink src/*.ink | entr -cr make` so every file change assembles and runs a program to test
- `ls ./b.out | entr -cr objdump -d -Mintel ./b.out` so that every time the executable is re-compiled, I can see the disassembly of the executable and check it against the intended assmbly code.

