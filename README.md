# August ü™ì

**August** is an assembler written from scratch in [Ink](https://dotink.co/) for me to learn about assemblers, linkers, and compiler backends. It currently aims to support assembling and statically linking [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) executables for ARM, RISC-V, and x86_64 architectures, though Mach-O support for ARM and x86_64 are under consideration. In the long term, August might also become a code generation backend for a compiler for some small subset of C written in Ink.

_August is ‚ö†Ô∏è under development ‚ö†Ô∏è. Many parts of the system do not work at all yet._

## Design

August provides a CLI, `./src/cli.ink`, that currently takes a single assembly program and emits a single statically-linked x86_64 ELF executable. Under the hood, August reads the assembly program, parses it into a simple representation of symbols and sections in the source, assembles it into machine code, and links it all together with a minimal ELF linker.

At the moment, the assembler and linker are pretty tightly integrated. The ELF linker assumes that only two sections are used, `.text` and `.rodata`, and the assembler generates code with that assumption. The virtual address table for the generated executable is also currently hard-coded into the linker and relied on by the assembler when resolving symbols.

Here's a transcript of a shell session that demonstrates what August can do today. We take a bare-bones Hello World program for Linux on x86_64, assemble it with August, run it, and dump the generated assembly with `objdump`.

```asm
$ cat test/asm/004.asm
; Hello World

section .text

mov eax 0x1     ; write syscall
mov edi 0x1     ; stdout
mov esi msg     ; string to print
mov edx len     ; length
syscall

mov eax 60      ; exit syscall
mov edi 0       ; exit code
syscall

section .rodata

msg:
    db "Hello, World!" 0xa
len:
    eq 14
```

Run the emitted program, which prints, "Hello, World!" and exits cleanly.

```bash
$ august test/asm/004.asm ./hello-world
executable written.

$ ./hello-world
Hello, World!

$ echo $?
0
```

If we disassemble the generated executable, we find the assembly we began with.

```asm
$ objdump -d ./hello-world

./hello-world:     file format elf64-x86-64

Disassembly of section .text:

0000000000401000 <.text>:
  401000:    b8 01 00 00 00           mov    $0x1,%eax
  401005:    bf 01 00 00 00           mov    $0x1,%edi
  40100a:    be 00 50 6b 00           mov    $0x6b5000,%esi
  40100f:    ba 0e 00 00 00           mov    $0xe,%edx
  401014:    0f 05                    syscall
  401016:    b8 3c 00 00 00           mov    $0x3c,%eax
  40101b:    bf 00 00 00 00           mov    $0x0,%edi
  401020:    0f 05                    syscall
    ...
```

### Assembler

The instruction encoding is handled by the [`./src/asm.ink`](src/asm.ink) library within the project. Currently, August can assemble simple assembly programs that work with 32-bit registers and the ALU, make system calls, and don't read or write to memory. Memory operations, stack manipulation, and function calls are coming soon.

_more to come._

### ELF Linker

August uses a library for constructing ELF executable files located at [`./src/elf.ink`](src/elf.ink). The ELF generated by the ELF library in August currently makes use of three sections:

- `.text` containing the program text, i.e. translated x64 assembly.
- `.rodata` containing read-only data loaded into process memory as read-only
- `.shstrtab` containing section headers

The content of `.text` and `.rodata` sections can be provided to the ELF library, which will return a fully linked ELF binary as the result.

_more to come._

## References and further reading

The ELF file format is quite well documented, especially in source bases of various linkers, assemblers, and kernels, but the available reference material for _implementing_ an ELF linker is not...what you would call super accessible. In the process of building August, I've found the following references particularly helpful.

- [`man elf` on Linux](https://man7.org/linux/man-pages/man5/elf.5.html) and the `elf` header file in the kernel sources, which provide the canonical reference for implementations of ELF files
- [A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux](http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html), which breaks down the ELF format for executable files at a high level
- [LWN's write-up of the Linux kernel's view of ELF executables](https://lwn.net/Articles/631631/), with another breakdown of ELF executables
- [Solaris's documentation on ELF object files](https://docs.oracle.com/cd/E53394_01/html/E54813/chapter6-93046.html#scrolltoc), a good in-depth reference
- [Notes on the ELF specification](http://www.muppetlabs.com/~breadbox/software/ELF.txt), which is long but very, very comprehensive, occasionally useful for studying edge cases

In writing an x86/x64 assembler, the following were especially helpful to get me up to speed.

- [The x86asm.net ISA reference](http://ref.x86asm.net/coder64.html), which is comprehensive enough for a toy assembler and easy to navigate once you get used to the compact notation
- [Encoding x86 Instructions](http://www.cs.loyola.edu/~binkley/371/Encoding_Real_x86_Instructions.html), which was a helpful guide to understanding how x86 and x64 instructions are encoded
- The [x64 cheat sheet](http://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf) for a handy list of the core x86/x64 instruction set

## Development

To work on August, you obviously need [Ink](https://dotink.co/) installed. [Inkfmt](https://github.com/thesephist/inkfmt) is also useful for auto-formatting code, which you can run with `make format` or `make f`.

When I work on August (especially the assembler), I usually have two other panes open, running:

- `ls test/asm/*.asm lib/*.ink src/*.ink | entr -cr make` so every file change assembles and runs a program to test
- `ls ./b.out | entr -cr objdump -d -Mintel ./b.out` so that every time the executable is re-compiled, I can see the disassembly of the executable and check it against the intended assmbly code.

